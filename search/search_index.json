{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>I am Vinicius Agostini, a Machine Learning Engineer \ud83d\udcbb with a heavy bias towards the software engineering aspect of it.</p> <p>I am interested in topics that range from coding best practices in ML to microservices and event-driven systems. I also have a small background in competitive programming from my early college years.</p> <p>This is a collection of anything that I want to write about. The reasoning for the posts here are not only to share my knowledge but also to serve the purpose of making me write about what I'm learning or practicing.</p> <p>Take everything with a grain of salt, I may be wrong and will eventually try to correct and improve posts over time. The posts should not be viewed as final or absolute truth.</p> <p> GitHub \\(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\) LinkedIn</p>"},{"location":"coding_problems/group_anagrams/","title":"Group Anagrams","text":""},{"location":"coding_problems/group_anagrams/#problem-statement","title":"Problem Statement","text":"<p>Given an array of strings <code>words</code>, group the anagrams together. You can return the answer in any order.</p> <p>Note</p> <p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>"},{"location":"coding_problems/group_anagrams/#solution","title":"Solution","text":"<p>The words that should be on the same group are the words that have the same frequencies for each letter on the alphabet. So all we have to do is count the frequencies for each word and somehow track the ones that are equal.</p> <p><pre><code>from collections import defaultdict\n\n\ndef idx(ch: str) -&gt; int:\n\"\"\"Utility function to map character to 0..26\"\"\"\n    return ord(ch) - ord(\"a\")\n\n\ndef count_characters(word: str) -&gt; list[int]:\n\"\"\"Utility function to count characters of word\"\"\"\n    count = [0] * 27\n\n    for ch in word:\n        count[idx(ch)] += 1\n\n    return count\n\n\ndef count_to_str(count: list[int]) -&gt; str:\n\"\"\"Utility function to represent a frequency count as a hashable str\"\"\"\n    return \",\".join(map(str, count))\n\n\ndef group_anagrams(words: list[str]) -&gt; list[list[str]]:\n    anagrams = defaultdict(list)\n\n    for word in words:\n        count = count_characters(word)\n        hash_key = count_to_str(count)\n        anagrams[hash_key].append(word)\n\n    return [key for _, key in anagrams.items()]\n</code></pre> The idea behind this solution is that we can use a string representing the character frequencies as index to a dictionary to group the words with the same letters.</p> <p>Things to note:</p> <ul> <li>The <code>idx</code> function is not strictly needed, but the array would need to be unnecessarily larger</li> <li>It is important to create the string representing the count in a way that the numbers don't get mixed up<ul> <li>For example, without the commas you wouldn't be able to differ \"111...\" from \"11,1,...\"</li> </ul> </li> </ul>"},{"location":"coding_problems/group_anagrams/#complexity-analysis","title":"Complexity Analysis","text":"TimeSpace <p>First let's have a look at the utility functions:</p> <ul> <li><code>count_characters(word)</code>: \\(O(L)\\) -- \\(L\\) is the length of the words</li> <li><code>count_to_str(count)</code>: \\(O(1)\\)</li> </ul> <p>Finally, the main loop calls <code>count_characters</code> and <code>count_to_str</code> \\(N\\) times, so in total we have \\(O(NL + N)\\), as appending to the list and inserting in the dictionary are \\(O(1)\\).</p> <p>Here we only keep an array of size 27 and a dictionary which will hold the \\(N\\) words in at most \\(N\\) keys. Therefore, we have \\(O(N)\\) space complexity.</p>"},{"location":"coding_problems/minimize_sum_array_k_reductions/","title":"Minimize Sum of Array with at most K reductions","text":"<p>Given an array of integers\u00a0<code>arr[]</code> consisting of\u00a0N integers, the task is to minimize the sum of the given array by performing at most\u00a0K\u00a0operations, where each operation involves reducing an array element\u00a0\\(arr[i]\\) to \\(\\left\\lfloor{\\frac{arr[i]}{2}}\\right\\rfloor\\).</p>"},{"location":"coding_problems/minimize_sum_array_k_reductions/#solution","title":"Solution","text":"<p>To minimize the final sum of the array, we should try to maximize the reductions. We can do that by choosing to reduce the largest element at every iteration.</p>"},{"location":"coding_problems/minimize_sum_array_k_reductions/#approach-use-max-heap","title":"Approach: Use Max-Heap","text":"<p>Python has a <code>heapq</code> module that contains functions that operate on lists with heap semantics. The only caveat here is that Python only implements a MinHeap by default, so we have a few options to circumvent that:</p> Negate the values in the arrayCustom MaxHeap class based on <code>heapq</code> <pre><code>from heapq import heapify, heappop, heappush\n\ndef solve(a, k):\n    # trick to turn min-heap into max-heap\n    a = [-x for x in a]\n    heapify(a)\n\n    for _ in range(k):\n        max_elem = -heappop(a)\n        new_elem = max_elem // 2\n        heappush(a, -new_elem)\n\n    # remember to invert the signal again\n    return sum((-x for x in a))\n</code></pre> <pre><code>from __future__ import annotations\n\nimport heapq\n\nclass MaxHeap:\n\"\"\"Uses negative trick to turn min-heap into max-heap\"\"\"\n\n    def __init__(self, data: list[int] | None):\n        self.data: list[int] = []\n\n        if data is not None:\n            for item in data:\n                self.push(item)\n\n    def __getitem__(self, key) -&gt; int:\n        return -self.data[key]\n\n    def push(self, item: int):\n        heapq.heappush(self.data, -item)\n\n    def pop(self) -&gt; int:\n        return -heapq.heappop(self.data)\n\ndef solve(a, k):\n    h = MaxHeap(data=a)\n\n    for _ in range(k):\n        max_elem = h.pop()\n        new_elem = max_elem // 2\n        h.push(new_elem)\n\n    return sum(h)\n</code></pre>"},{"location":"coding_problems/minimize_sum_array_k_reductions/#complexity-analysis","title":"Complexity Analysis","text":"TimeSpace <p>Inserting a new item in a heap take \\(O(\\log n)\\) time where \\(n\\) is the number of elements. Popping the largest element is \\(O(1)\\).</p> <p>So, building our heap from the input data takes \\(O(n \\log n)\\) time and the subsequent \\(K\\) operations will take \\(O(k \\log n)\\). Adding that up we get \\(O(n \\log n + k \\log n)\\).</p> <p>We start with a list of \\(N\\) elements and the reductions don't change the amount of items stored in the list, so \\(O(n)\\).</p>"}]}